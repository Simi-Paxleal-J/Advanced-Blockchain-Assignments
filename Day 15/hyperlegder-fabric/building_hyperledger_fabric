This piece is about my experience in creating a blockchain PoC application for land and title recording on blockchain leveraging Hyperledger Fabric (HF) blockchain platform. It may benefit those who just got started on HF or intend to learn it and for those who are already experienced in HF it may offer another equally viable option. It’s pretty long, but for most readers who are interested in blockchain technology, your time would be well spent.
Let us first set up our goal and then see how we can achieve it.
Here our goal is to create a web application for recording house transactions (buying and selling houses) on a small permissioned blockchain and for being able to search for them. And we’ve decided to use Hyperledger Fabric platform to do the job.
At the end of the day, we want this application look like below (with terse explanation unless self explanatory).
Our first screen is the web application’s Login page with background of Hyperledger Fabric api service debugging output:


User chaincode has four life cycle of “Install”, “Instantiate”, “Invoke” and “Query”.
“Install” essentially maps the chaincode’s location/path, thus, when need arises it can be found and utilized.
“Instantiate” would create a container image to support all future invocation and query needs of the particular chaincode, and that’s why “instantiate” takes longer to complete.
“Invoke”, plainly put, write data or put data onto the blockchain.
“Query”, simply put, get data or retrieve data from the blockchain.
“Install” and “Instantiate” beyond Basics
In my opinion, in a production environment, chaincode install and instantiate would usually be a one-time process, once a particular chaincode is installed and instantiated they would “always” be there for future use such as for “invoke” and/or “query”. Knowing how to install and instantiate is critically important.
There are at least 3 methods to install and instantiate chaincode.
(a) via the “peer” command at CLI command prompt and this is a good method.
(b) via call to a Fabric REST api server, in my experience this method is pretty good as well
© via Hyperledger Composer and this introduces a totally new paradigm. While I have highest respect for people working on Hyperledger project, I have an issue with how it fits into the overall Fabric architecture, by having Composer to re-create a Fabric network etc… it seems going many directions / introducing unnecessary, extra processes, so, personally I’m avoiding this option. See the following note and URL for details on the future prospect of this option, “Speaking on behalf of my team in XYZ, we’re all incredibly proud of what we’ve contributed to Composer over the last couple of years, and we are grateful to the community for all your feedback and contributions. However — we at XYZ believe that there are some fundamental problems with the architecture and design of Composer, as it is today, that have made us reconsider our future direction and plans.”, contac me for details.
Regarding method (a), to try it, you could first bring up the “first-network”, then go to the CLI command prompt ( docker exec -it cli bash ), now you can install and instantiate chaincode, since “mycc” has already been installed, you may install “fabcar”, look for its path for install “mycc” from the “./byfn.sh up” screen when you brought up the Fabric network.
Once installed, you can verify if it’s truly installed via “peer chaincode list — installed” command, then, instantiate “fabcar” chaincode by looking at how it’s done for the “mycc” chaincode ( and make sure you’re ONLINE, it needs some npm reference ). It may take several minutes, once done, use “peer chaincode list -C mychannel — instantiated” to verify if it’s truly instantiated.
Thus, once again it’s important to obtain an Ability to perform chaincode life cycle, as mentioned above, install, instantiate, invoke and query.
Chaincode coding-wise, a great way to learn is to read and understand sample chaincode. Both “Balance-Transfer” sample app and “Fabcar” sample app are good examples. The important thing is a willingness to experiment with or tweak with them, thus, we would gain new understanding or even some sort of discovery. For instance, for the “First-Network” sample app, the “Instantiate” actually writes data to the chain while the “Instantiate” for the “Fabcar” sample app does not. Thus, we know that “Instantiate” can be written in a way that fits our needs better vs. it must do this or that.
Now, let’s map all the above generic learning about chaincode into the House Transaction blockchain application, in this case, two key functionality are “addTransaction” and “queryTransaction” and since I’m using Node.js for chaincode, one node.js source code file can address them both and once done, we make the package.json configuration file to reflect this node.js source code file. And then, we are ready to go for the chaincode life cycle as described above.
So, now, we have built a blockchain network using Hyperledger Fabric platform and have created chaincode for this House Transaction blockchain application, but our end users would need to access it via web or their mobile phone, what’s next?
Naturally, developing web and/or mobile interface into the chain and since this application is for business I’ll start with web application first. So, now it brings us to the next part.
Part Three — Web and/or Mobile Application on Top of the Blockchain
The very first question now is how to connect the chaincode with the chain’s State database and ledger and then how to connect the chaincode to web app, so, the chaincode sort of sits in the middle. An api is a way to go to make the connections for both ends. Then api-wise, we have Fabric api and Composer api. As stated above, I’m a fan of Occam’s Razor principle, solving problems efficiently (vs. any convoluted method regardless), thus, I’ve eliminated Composer api, which means Fabric api is my choice.
In a nutshell, the Fabric API server works like this, on the chaincode side, it leverages a low level api to communicate with chaincode, this low level api is called “shim”, also called “fabric-shim”, then, on the web site, some server side script calls the Fabric api for chain data action.
Now, let’s expand on the above, we first run the Fabric API server, then, we set up a web server, create some server side code to call the API server for different types of chain transaction needs such as “install”, “instantiate”, “invoke” and “query”.
And now, let’s turn the conceptual highlight of the above paragraph into this House Transaction application, for server side code we would need some code for the login page ( the FORM ) and some code to embed security/authentication logic, and then create html FORM to accept house transaction data input, some code to accept that transaction and write data to the chain, and then some more code to accept query for transactions, and some code to process such query/search, get data from the chain and then present the user with such results or none if not found.
